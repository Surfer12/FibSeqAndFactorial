/**
 * Strategy pattern implementation using functional interfaces and lambda expressions.
 * This approach enhances flexibility and simplifies the implementation.
 *
 * @param <DataType> The type of data being processed.
 */
@FunctionalInterface
public interface DataProcessingStrategy<DataType> {
    void process(DataType data);
}

public class DataProcessor<DataType> {
    private DataProcessingStrategy<DataType> processingStrategy;

    public DataProcessor(DataProcessingStrategy<DataType> processingStrategy) {
        this.processingStrategy = processingStrategy;
    }

    public void executeProcessing(DataType data) {
        processingStrategy.process(data);
    }

    public static void main(String[] args) {
        // Using a lambda expression for the processing strategy
        DataProcessor<String> stringProcessor = new DataProcessor<>(data -> 
            System.out.println(data.toUpperCase())
        );
        stringProcessor.executeProcessing("hello world");

        // Changing the processing strategy at runtime
        stringProcessor = new DataProcessor<>(data -> 
            System.out.println(new StringBuilder(data).reverse())
        );
        stringProcessor.executeProcessing("hello world");
    }
}